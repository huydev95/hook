var URL = require('url');

class ProxyServer {
  function initialize(port, host) {
    this.client  = require('http').createClient(port, host); 

    this.client.addListener('error', function(err) {
      console.log("Unable to connect to client");
    });

    this.preFilters  = [];
    this.postFilters = [];
    this.resets      = [];
  }

  function getProxiedRequest($r) {
    var req = $r.frontend.request;
    return this.client.request(req.method, req.url, req.headers);
  }

  function passedPreFilters($r) {
    foreach (var f in this.preFilters) {
      var val = f($r);
      if (val == false) return false;
    }
    return true;
  }

  function passedPostFilters($r) {
    foreach (var f in this.postFilters) {
      var val = f($r);
      if (val == false) return false;
    }
    return true;
  }

  function proxyRequest(serverReq, serverRes) {

    var url     = URL.parse(serverReq.url, true);
    var state   = {};
    var $r = {
      frontend: {
        request:  serverReq,
        response: serverRes
      },

      backend: {
        request:  null,
        response: null
      },

      state:  {},
      url:    url,
      params: url.query
    };

    if (!this.passedPreFilters($r)) return;

    var self = this;
    var clientReq = this.getProxiedRequest($r);
    $r.backend.request = clientReq;

    clientReq.addListener("response", #(clientRes) {
      $r.backend.response = clientRes;
      if (!self.passedPostFilters($r)) return;

      serverRes.writeHeader(clientRes.statusCode, clientRes.headers);

      clientRes.addListener("data", #{ serverRes.write($1, 'binary'); });
      clientRes.addListener("end",  #{ serverRes.end(); });
    });

    serverReq.addListener("data", #{ clientReq.write($1, 'binary') });
    serverReq.addListener("end", #{ clientReq.end(); });
  }

  function addFilter(filter) {
    if (filter.pre) {
      this.preFilters.push(#{ return filter.pre.apply(filter, arguments) });
    }

    if (filter.post) {
      this.postFilters.push(#{ return filter.post.apply(filter, arguments) });
    }

    if (filter.reset) {
      this.resets.push(#{ return filter.reset.apply(filter, arguments); });
    }

  }

  function reset() {
    foreach (var reset in this.resets) {
      reset();
    }
  }
}
